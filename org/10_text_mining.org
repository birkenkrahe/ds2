#+TITLE: Text mining - Bag of Words
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE:DSC205 Introduction to Advanced Data Science
#+STARTUP:overview hideblocks indent
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:R :exports both :results output :session *R* :noweb yes
* README

- Short introduction to text mining (TM) and bag-of-words

- Based on Kwartler, Text mining in practice with R (Wiley, 2019)

- Kwartler is also the author of the DataCamp course on TM with R

* Quick taste of test mining with ~qdap~

This is a quick example to demonstrate text mining using the ~qdap~
package that you need to install first:

- (Install and) load ~qdap~ and show all loaded packages. Run this code
  block twice.
  #+begin_src R :results output :session *R*
    library(qdap)
    search()
  #+end_src

  #+RESULTS:
  :  [1] ".GlobalEnv"               "package:qdap"
  :  [3] "package:RColorBrewer"     "package:qdapTools"
  :  [5] "package:qdapRegex"        "package:qdapDictionaries"
  :  [7] "ESSR"                     "package:stats"
  :  [9] "package:graphics"         "package:grDevices"
  : [11] "package:utils"            "package:datasets"
  : [13] "package:stringr"          "package:httr"
  : [15] "package:methods"          "Autoloads"
  : [17] "package:base"

- Store this text in a vector ~text~:
  #+begin_quote
  "DataCamp is the first online learning platform that focuses on
  building the best learning experience specifically for Data
  Science. We have offices in New York, London, and Belgium, and to
  date, we trained over 11 million (aspiring) data scientists in over
  150 countries. These data science enthusiasts completed more than
  667 million exercises. You can take free beginner courses, or
  subscribe for $25/month to get access to all premium courses."
  #+end_quote
  *In Emacs:*
  1) Mark the start of the text with ~C-SPC~ (CTRL + SPACEBAR)
  2) Go down to the end of the text with ~C-e~ (CTRL + e)
  3) Copy the text with ~M-w~ (ALT + w)
  4) Paste the text wherever you want to with ~C-y~ (CTRL + y)
  #+name: create_text
  #+begin_src R :session *R*
    text <- "DataCamp is the first online learning platform that focuses on building the best learning experience specifically for Data Science. We have offices in New York, London, and Belgium, and to date, we trained over 11 million (aspiring) data scientists in over 150 countries. These data science enthusiasts completed more than 667 million exercises. You can take free beginner courses, or subscribe for $25/month to get access to all premium courses."
  #+end_src

  #+RESULTS: create_text

- Print ~text~.
  #+begin_src R
    text
  #+end_src

  #+RESULTS:
  : [1] "DataCamp is the first online learning platform that focuses on building the best learning experience specifically for Data Science. We have offices in New York, London, and Belgium, and to date, we trained over 11 million (aspiring) data scientists in over 150 countries. These data science enthusiasts completed more than 667 million exercises. You can take free beginner courses, or subscribe for $25/month to get access to all premium courses."

- Check the data type of ~text~ with ~class~, and print its ~length~ and the
  number of its characters with ~nchar~:
  #+begin_src R :session :results output
    class(text)
    length(text)
    nchar(text)
  #+end_src

  #+RESULTS:
  : [1] "character"
  : [1] 1
  : [1] 446

- Find the 10 most frequent terms and store them in ~term_count~ using
  ~qdap::freq_terms~:
  #+begin_src R :session *R* :results output
    term_count <- freq_terms(text, 10)
    term_count
  #+end_src

  #+RESULTS:
  #+begin_example
     WORD     FREQ
  1  data        3
  2  to          3
  3  and         2
  4  courses     2
  5  for         2
  6  in          2
  7  learning    2
  8  million     2
  9  over        2
  10 science     2
  11 the         2
  12 we          2
  #+end_example

- If you compare with what we said above, you can see that this table
  is a transposed document matrix (TDM) with one feature (word
  frequency ~FREQ~).

- Plot the term count:
  #+begin_src R :results graphics file :file ../img/term_count.png :session *R*
    plot(term_count)
  #+end_src

  #+RESULTS:
  [[file:../img/term_count.png]]

* IN PROGRESS The ~tm~ text mining package

- The ~tm~ package for text mining comes with a /vignette/ ([[https://cran.r-project.org/web/packages/tm/vignettes/tm.pdf][Feinerer,
  2022]]). Its date reveals that the paper is up to date.

- Load ~tm~ (twice) and check the loaded package list with ~search()~:
  #+begin_src R
    library(tm)
    search()
  #+end_src

- There is no separate data package. Check which functions ~tm~ contains:
  #+begin_src R
    ls("package:tm")
  #+end_src

- Text documents are processed at different levels:
  1) *Strings* like "Hello world"
  2) *Documents* like a text of many strings stored as vector, dataframe
  3) *Corpora* as collections of documents

- The main purpose of these packages is to clean large bodies of
  diverse documents in preparation for more advanced analysis.

* Creating a vector source

- Let's get some text first:
  1) remove ~text~ from the R objects list
  2) read a CSV file into a header-less data frame
  3) transpose the data frame (columns become rows)
  4) turn transposed data frame into vector
  #+begin_src R
    rm(text)   # remove the old text vector (if it exists, otherwise: warning)
    read.csv(
      file="https://raw.githubusercontent.com/birkenkrahe/ds2/main/data/tm.csv",
      header=FALSE) -> text
    as.vector(t(text)) -> text
    str(text)
    text
  #+end_src

- Bonus question: can you prevent the system warning in the previous
  code block in case there is no ~text~ vector present in the
  environment, and produce your own /personalized/ warning message?
  #+begin_src R
    if (any(ls()=="text")) {
      rm(text)
    } else {
      warning(
        "There is no 'text' vector in the session in \n",
        getwd())
    }
  #+end_src

  #+RESULTS:
  : Warning message:
  : There is no 'text' vector in the session in 
  : c:/Users/birkenkrahe/Documents/GitHub/ml/org

- Use ~VectorSource~ to create a /source/ from the ~text~ vector, and show
  its structure with ~str~:
  #+begin_src R
    if (!any(search()=='package:tm')) library(tm)
    source <- VectorSource(text)
    str(source)
  #+end_src

- The source ~doc_source~ is a ~list~ of five elements and an attribute:
  1) ~encoding~ says that the content is encoded with apostrophs.
  2) ~length = 3~ is the length of the input vector
  3) ~position = 0~ means that there is no other document in the corpus
  4) ~reader~ is the function used to process the vector
  5) ~content~ is the content of the corpus - one string only
  6) ~attr~ is a vector that says what type of source this is
  #+begin_src R
    typeof(source)
  #+end_src

* Creating a volatile corpus

- To turn the ~VectorSource~ into a volatile (in-memory) corpus, use
  ~VCorpus~ (that's also a ~list~):
  #+begin_src R
    corpus <- VCorpus(VectorSource(text))  
    corpus
    typeof(corpus)
  #+end_src

- A corpus can have metadata - this only only has two "documents",
  i.e. the two strings. A corpus can have any number of documents.

- You can inspect the corpus with ~inspect~. This provides information
  about each of the documents -
  #+begin_src R
    inspect(corpus)
  #+end_src

- Individual documents can be accessed with the ~[[~ operator or via
  their name:
  #+begin_src R
    meta(corpus[[1]]) # metadata for document no. 1 (list index)
    meta(corpus[[1]],"language") # metadata for document language
  #+end_src

- Accessing the corpus document content with ~content~:
  #+begin_src R
    content(corpus[[3]])
  #+end_src

- You can also make a corpus from a data frame and store it
  permanently in a database using [[https://www.rdocumentation.org/packages/tm/versions/0.7-8/topics/PCorpus][the ~PCorpus~ function]].

* Cleaning a string

- Base R cleaning functions in ~tm~:
  #+attr_html: :width 400px
  #+caption: Text mining functions
  [[../img/10_clean.png]]

- The function ~tolower~ is actually a ~base R~ function:
  1) check out the namespace of ~tolower~ with ~environment~
  2) print the first message of the ~corpus~ with ~content~
  3) apply ~tolower~ to the first message in our ~corpus~
  #+begin_src R
    environment(tolower)
    content(corpus[[1]])
    tolower(content(corpus[[1]]))
  #+end_src

- Achieve the last result using a pipeline with the ~|>~ operator:
  #+begin_src R
    corpus[[1]] |>
      content() |>
      tolower()
  #+end_src

- Save the 2nd ~corpus~ document in an object ~t~, then use the following
  functions (in this order) on ~t~ and save the result in ~tc~:
  1) ~removeWords(t,stopwords("en"))~
  2) ~removeNumbers~
  3) ~removePunctuation~
  4) ~stripWhitespace~
  5) ~tolower~
  #+begin_src R
    content(corpus[[2]]) -> t
    tolower(
      stripWhitespace(
        removePunctuation(
          removeNumbers(
            removeWords(t, stopwords("en")))))) -> tc
    tc
  #+end_src

- Here, ~stopwords~ is a function, and ~stopwords("en")~ is a dictionary
  of English "small" words to be removed:
  #+begin_src R
    stopwords("en")
  #+end_src

- Check if the words "good" and "at" are in the English stop words
  dictionary:
  #+begin_src R
    any(stopwords("en")==c("at"))
    any(stopwords("en")==c("good"))
  #+end_src

- Why is "good" not a stop word?

- Recreate the cleaning from before using a pipeline:
  #+begin_src R
    content(corpus[[2]]) -> t
    t |>
      removeWords(stopwords("en")) |>
      removeNumbers() |>
      removePunctuation() |>
      stripWhitespace() |>
      tolower()
  #+end_src

  #+RESULTS:
  : [1] "if want learn r learn packages cheat sheet these tools rstats datascience httpsbufflykrpgi"

- The ~qdap~ package contains even more cleaning functions. Check the
  methods in the package:
  #+begin_src R
    library(qdap)
    ls('package:qdap')
  #+end_src

* READ Using ~gsub~ and ~tm::removePunctuation~

Source: Lantz, ML with R (2019)
[[../img/removePunctuation.png]]
* Cleaning a corpus

- To clean a corpus (a collection of different documents), use ~tm_map~,
  which works as a wrapper. For example for ~removePunctuation~ and our ~corpus~:
  #+begin_src R
    library(tm)
    nchar(content(corpus[[3]]))
    nchar(content(tm_map(corpus, removePunctuation)[[3]]))
    nchar(content(tm_map(corpus, removeWords, words=stopwords("en"))[[3]]))
    nchar(content(tm_map(corpus, content_transformer(tolower))[[3]]))
  #+end_src

- Bonus: we only have 3 strings in the corpus, so an index 4 will be
  out of bounds. How can you make the first command safe against this
  error?
  #+begin_src R
    library(tm)
    length(content(corpus)) -> b
    for (i in 1:4) {
      if (i > b) {
        stop("Index out of bounds: only ",b,
             " elements exist.\nCommand terminated.")
      } else {
        print(nchar(content(corpus[[i]])))
      }
    }
    #+end_src
    
* Creating a Term-Document-Matrix (TDM)
#+attr_latex: :width 400px
#+caption: TDM and DTM for a corpus of tweets.
[[../img/tdm_dtm.png]]

- Bag-of-words only cares about term (aka word) frequencies - this
  information is contained in a Term-Document-Matrix whose rows are
  terms and whose columns are the indidivual documents of the corpus.

- The function ~clean_corpus~ has been defined and contains all the
  cleaning operations you've seen so far:
  1) run ~clean_corpus~ on ~corpus~ and save in object ~clean_corpus~
  2) print element 2 of ~clean_corpus~
  #+begin_src R
    <<clean_corpus>>
    clean_corpus(corpus) -> clean_corpus
    content(clean_corpus[[2]])
  #+end_src

- Notice that the order of operations matters a lot for a truly
  "clean" result. For example, applying ~tolower~ after ~removeWords~ will
  leave "If" because the dictionary only contains "if".

- The ~tm::TermDocumentMatrix~~ function turns the ~clean_corpus~ into a TDM:
  #+begin_src R
    tdm <- TermDocumentMatrix(clean_corpus)
    tdm
  #+end_src

- Look at the structure - you can see that the column vector names
  contain the term and document information:
  #+begin_src R
    str(tdm)
  #+end_src

- Transpose the TDM to a DTM using ~base::t~ (or use ~DocumentTermMatrix~
  on the clean corpus):
  #+begin_src R
    dtm <- t(tdm)
    dtm
    tdm
  #+end_src

* Analyze and visualize the TDM

- All we're interested in, and all we can analyze and visualize, are
  term frequencies.

- To see counts, you can transform the TDM into a matrix:
  #+begin_src R
    as.matrix(tdm) -> m
    head(m, 10)
  #+end_src
  
- To see top counts:
  1) sum over all documents and get the frequencies for each term
  2) sort the entries in decreasing order
  3) print the top six entries
  #+begin_src R
    rowSums(m) -> freq
    sort(freq, decreasing=TRUE) -> sorted
    head(sorted)
  #+end_src

- You can visualize the results as a barchart or as a wordcloud. For
  the wordclouds, we need the ~wordcloud~ package.

- Barchart:
  #+begin_src R :results graphics file :file ../img/text_chart.png
    barplot(rev(sorted),
            horiz=TRUE,
            main="Word frequencies",
            xlab="Counts",
            las=1)
  #+end_src

- For the wordcloud, we transform the sorted, named frequency vector
  ~sorted~ into a dataframe and then remove the ~rownames~:
  #+begin_src R
    library(wordcloud)
    df <- data.frame(term=names(sorted),
                     num=sorted)
    rownames(df) <- NULL
    head(df,10)
  #+end_src

  #+RESULTS:
  #+begin_example
  Warning message:
  package 'wordcloud' was built under R version 4.2.3
            term num
  1         free   2
  2        learn   2
  3       access   1
  4    available   1
  5         boom   1
  6       called   1
  7        cheat   1
  8   conception   1
  9        crash   1
  10 datascience   1
  #+end_example

- Now we apply the ~wordcloud~ function, which requires words (~term~),
  and frequencies (~freq~). Check the arguments of this function:
  #+begin_src R
    args(wordcloud)
  #+end_src

- Create the word cloud:
  #+begin_src R :results graphics file :file ../img/wordcloud.png
    wordcloud(words = df$term,
              freq = df$num,
              max.words=20,
              color="blue")
  #+end_src

* Resources

- Cleaning function for ~corpus~:
  #+name: clean_corpus
  #+begin_src R :results silent
    clean_corpus <- function(corpus) {
      corpus <- tm_map(corpus,
                       removeNumbers)
      corpus <- tm_map(corpus,
                       removePunctuation)
      corpus <- tm_map(corpus,
                       content_transformer(tolower))
      corpus <- tm_map(corpus,
                       removeWords,
                       words = c(stopwords("en")))
      corpus <- tm_map(corpus,
                       stripWhitespace)
      return(corpus)
    }
  #+end_src
